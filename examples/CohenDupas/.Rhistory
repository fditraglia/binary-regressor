R2 <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (R1 - 2 * W * R2) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
out <- c(OLS, IV, a1_a0)
names(out) <- c("OLS", "IV", "a1_a0")
return(out)
}
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.05, 0.3))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.0, 0.3))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
quantile(sim$a1_a0)
inData <- dgp(0.1, 0.4)
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
a1_a0
inData <- dgp(0.1, 0.4, n = 100000)
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
a1_a0
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
?polyroot
discoveries
?discoveries
example(discoveries)
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
disc <- sqrt(3 * R^2 - 2 * S)
disc
term1 <- -0.5 * R/W
disc <- sqrt(3 * R^2 - 2 * S)
term2 <- 0.5 * disc/W
root1 <- term1 + term2
root2 <- term1 - term2
root1
root2
inData <- dgp(0.1, 0.4, n = 1000000)
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
term1 <- -0.5 * R/W
disc <- sqrt(3 * R^2 - 2 * S)
term2 <- 0.5 * disc/W
root1 <- term1 + term2
root2 <- term1 - term2
root1
root2
rm(list = ls())
# A selection model with randomly assigned offer of treatment
# and non-differential measurement error
dgp <- function(a0, a1, b = 2, c = 0.5, g0 = -1, g1 = 5, s_noise = 1,
s_ability = 1, q = 0.5, n = 200){
z <- rbinom(n, 1, q) #offer of treatment
ability <- rnorm(n, 0, s_ability)
xstar <- as.numeric(g0 + g1 * z + ability > 0) #select into treatment
e <- rnorm(n, 0, s_noise) + ability
y <- c + b * xstar + e
#mis-classification
x <- (1 - xstar) * rbinom(n, 1, a0) + xstar * rbinom(n, 1, 1 - a1)
return(data.frame(x, y, z))
}
# Calculate various estimators
est <- function(inData){
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
term1 <- -0.5 * R/W
disc <- sqrt(3 * R^2 - 2 * S)
term2 <- 0.5 * disc/W
root1 <- term1 + term2
root2 <- term1 - term2
out <- c(OLS, IV, a1_a0, root1, root2)
names(out) <- c("OLS", "IV", "a1_a0", "root1", "root2")
return(out)
}
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.0, 0.3))))
warnings()
sim <- t(replicate(5000, est(dgp(0.0, 0.3))))
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.0, 0.3))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
head(sim)
hist(sim$root1)
hist(sim$root2)
mean(sim$root2)
mean(sim$root2, na.rm = TRUE)
mean(sim$root1, na.rm = TRUE)
1 - 0.3
# and non-differential measurement error
# A selection model with randomly assigned offer of treatment
# and non-differential measurement error
dgp <- function(a0, a1, b = 2, c = 0.5, g0 = -1, g1 = 5, s_noise = 1,
s_ability = 1, q = 0.5, n = 500){
z <- rbinom(n, 1, q) #offer of treatment
ability <- rnorm(n, 0, s_ability)
xstar <- as.numeric(g0 + g1 * z + ability > 0) #select into treatment
e <- rnorm(n, 0, s_noise) + ability
y <- c + b * xstar + e
#mis-classification
x <- (1 - xstar) * rbinom(n, 1, a0) + xstar * rbinom(n, 1, 1 - a1)
return(data.frame(x, y, z))
}
# Calculate various estimators
est <- function(inData){
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
term1 <- -0.5 * R/W
disc <- sqrt(3 * R^2 - 2 * S)
term2 <- 0.5 * disc/W
root1 <- term1 + term2
root2 <- term1 - term2
out <- c(OLS, IV, a1_a0, root1, root2)
names(out) <- c("OLS", "IV", "a1_a0", "root1", "root2")
return(out)
}
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.0, 0.3))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root2)
hist(sim$root1)
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.15, 0.3))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.1, 0.3))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
hist(sim$a1_a0)
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0, 0))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
hist(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
quantile(sim$a1_a0, c(0.5, 0.95))
quantile(sim$a1_a0, c(0.05, 0.95))
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.1, 0.1))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
hist(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
quantile(sim$a1_a0, c(0.05, 0.95))
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.1, 0.3))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
hist(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
rm(list = ls())
# A selection model with randomly assigned offer of treatment
# and non-differential measurement error
dgp <- function(a0, a1, b = 2, c = 0.5, g0 = -1, g1 = 5, s_noise = 1,
s_ability = 1, q = 0.5, n = 500){
z <- rbinom(n, 1, q) #offer of treatment
ability <- rnorm(n, 0, s_ability)
xstar <- as.numeric(g0 + g1 * z + ability > 0) #select into treatment
e <- rnorm(n, 0, s_noise) + ability
y <- c + b * xstar + e
#mis-classification
x <- (1 - xstar) * rbinom(n, 1, a0) + xstar * rbinom(n, 1, 1 - a1)
return(data.frame(x, y, z))
}
# Calculate various estimators
est <- function(inData){
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
term1 <- -0.5 * R/W
disc <- sqrt(3 * R^2 - 2 * S)
term2 <- 0.5 * disc/W
root1 <- term1 + term2
root2 <- term1 - term2
out <- c(OLS, IV, a1_a0, root1, root2)
names(out) <- c("OLS", "IV", "a1_a0", "root1", "root2")
return(out)
}
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.1, 0.6))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
hist(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
# and non-differential measurement error
dgp <- function(a0, a1, b = 2, c = 0.5, g0 = -1, g1 = 5, s_noise = 1,
s_ability = 1, q = 0.5, n = 200){
z <- rbinom(n, 1, q) #offer of treatment
ability <- rnorm(n, 0, s_ability)
xstar <- as.numeric(g0 + g1 * z + ability > 0) #select into treatment
e <- rnorm(n, 0, s_noise) + ability
y <- c + b * xstar + e
#mis-classification
x <- (1 - xstar) * rbinom(n, 1, a0) + xstar * rbinom(n, 1, 1 - a1)
return(data.frame(x, y, z))
}
# Calculate various estimators
est <- function(inData){
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
term1 <- -0.5 * R/W
disc <- sqrt(3 * R^2 - 2 * S)
term2 <- 0.5 * disc/W
root1 <- term1 + term2
root2 <- term1 - term2
out <- c(OLS, IV, a1_a0, root1, root2)
names(out) <- c("OLS", "IV", "a1_a0", "root1", "root2")
return(out)
}
rm(list = ls())
dgp <- function(a0, a1, b = 2, c = 0.5, g0 = -1, g1 = 5, s_noise = 1,
s_ability = 1, q = 0.5, n = 200){
z <- rbinom(n, 1, q) #offer of treatment
ability <- rnorm(n, 0, s_ability)
xstar <- as.numeric(g0 + g1 * z + ability > 0) #select into treatment
e <- rnorm(n, 0, s_noise) + ability
y <- c + b * xstar + e
#mis-classification
x <- (1 - xstar) * rbinom(n, 1, a0) + xstar * rbinom(n, 1, 1 - a1)
return(data.frame(x, y, z))
}
# Calculate various estimators
est <- function(inData){
OLS <- with(inData, cov(x,y)/var(x))
IV <- with(inData, cov(z,y)/cov(z,x))
dat0 <- subset(inData, z == 0)
dat1 <- subset(inData, z == 1)
p1_hat <- mean(dat1$x)
p0_hat <- mean(dat0$x)
W <- IV
Dy2 <- mean(dat1$y^2) - mean(dat0$y^2)
DyT <- mean(dat1$y * dat1$x) - mean(dat0$y * dat0$x)
R <- (Dy2 - 2 * W * DyT) / (W * (p1_hat - p0_hat))
a1_a0 <- 1 + R/W
Dy3 <- mean(dat1$y^3) - mean(dat0$y^3)
Dy2T <- mean(dat1$y^2 * dat1$x) - mean(dat0$y^2 * dat0$x)
S <- (Dy3 - 3 * W * (Dy2T + R * DyT)) / (W * (p1_hat - p0_hat))
term1 <- -0.5 * R/W
disc <- sqrt(3 * R^2 - 2 * S)
term2 <- 0.5 * disc/W
root1 <- term1 + term2
root2 <- term1 - term2
out <- c(OLS, IV, a1_a0, root1, root2)
names(out) <- c("OLS", "IV", "a1_a0", "root1", "root2")
return(out)
}
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.1, 0.6))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
hist(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
mean(sim$a1_a0)
hist(sim$a1_a0)
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root2)
mean(sim$a1_a0)
hist(sim$a1_a0)
quantile(sim$a1_a0, c(0.05, 0.95))
quantile(sim$a1_a0, c(0.05, 0.95))
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
set.seed(8372)
sim <- t(replicate(5000, est(dgp(0.1, 0.2))))
sim <- as.data.frame(sim)
mean(sim$a1_a0)
hist(sim$a1_a0)
quantile(sim$a1_a0, c(0.05, 0.95))
qqnorm(sim$a1_a0)
qqline(sim$a1_a0)
mean(sim$root1, na.rm = TRUE)
mean(sim$root2, na.rm = TRUE)
hist(sim$root1)
hist(sim$root1)
hist(sim$root2)
hist(sim$root1)
qqplot(sim$root1)
qqplot(sim$root1)
qnorm(sim$root1)
qqnorm(sim$root1)
qqline(sim$root1)
hist(sim$root2)
qqnorm(sim$root2)
qqline(sim$root2)
setwd("~/binary-regressor/examples/CohenDupas/")
system("ls")
library(foreign)
#Test our method on Cohen and Dupas Dataset
setwd("~/binary-regressor/examples/CohenDupas/")
library(foreign)
# Clinic-level baseline data
base <- read.dta("clinic_level_baselinedata.dta")
# Clinic-level nets sales
sales <- read.dta("clinic_level_nets_sales.dta")
# Followup survey
followup <- read.dta("Followup_survey.dta")
# PV survey
pv <- read.dta("PV_survey.dta")
names(base)
names(pv)
names(base)
names(pv)
clinics <- with(base, dataframe(clinicid, treatment))
clinics <- with(base, data.frame(clinicid, treatment))
women <- with(pv, data.frame(clinicid, PV_buynet, PV_hbrate))
?merge
clinics
data <- merge(clinics, women)
data
clinics <- with(base, data.frame(clinicid, treatment, Netprice))
names(clinics)
names(base)
names(base)
names(pv)
clinics <- with(base, data.frame(clinicid, treatment, Netprice))
women <- with(pv, data.frame(clinicid, transactionprice, PV_buynet, PV_hbrate))
clinics <- with(base, data.frame(clinicid, treatment, netprice))
women <- with(pv, data.frame(clinicid, transactionprice, PV_buynet, PV_hbrate))
data <- merge(clinics, women)
head(data)
data
summary(data)
women
View(pv)
summary(data)
names(followup)
followup
followup$FOL_sampled
names(followup)
clinics <- with(base, data.frame(clinicid, treatment, netprice))
women <- with(pv, data.frame(clinicid, respid, transactionprice, PV_buynet, PV_hbrate))
data <- merge(clinics, women)
summary(data)
data$respid
length(unique(data$respid))
length(respid)
length(data$respid)
rm(list = ls())
#Test our method on Cohen and Dupas Dataset
setwd("~/binary-regressor/examples/CohenDupas/")
library(foreign)
# Baseline clinic characteristics
base <- read.dta("clinic_level_baselinedata.dta")
# Clinic-level nets sales
sales <- read.dta("clinic_level_nets_sales.dta")
# Follow-up survey
followup <- read.dta("Followup_survey.dta")
# Pre-natal visit survey
pv <- read.dta("PV_survey.dta")
#------------------------------------------------------------------
# Create a dataframe of the following variables for all women in
# the study by merging selected columns of base and pv based on
# Clinicid
#------------------------------------------------------------------
#   Treatment           equals 1 if woman visits a clinic that was
#                         randomized into treatment group
#   netprice            randomized price at which clinic sells the
#                         bednets (0, 10, 20, 40)
#   transactionprice    final price paid for net, after discount and
#                         lottery if applicable
#   PV_hbrate           hemoglobin level at prenatal visit
#   PV_buynet           self-report equals 1 if woman says she
#                         bought mosquito net
#------------------------------------------------------------------
clinics <- with(base, data.frame(clinicid, treatment, netprice))
women <- with(pv, data.frame(clinicid, respid, transactionprice, PV_buynet, PV_hbrate))
data <- merge(clinics, women)
summary(data)
data
data
summary(data)
table(data$netprice)
table(data$treatment)
data
head(followup)

########Functions used in Monte Carlo Studies########

###Given data frame, generate intervals on which the maximands of the statistic are evaluated. 

generate.grids.coarse<-function(data,size1,size0){
                                      Yd1z0<-sort(subset(data[,1], (data[,2]==1)&(data[,3]==0)));
                                      Yd0z1<-sort(subset(data[,1], (data[,2]==0)&(data[,3]==1)));
                                      Y1grid<-unique(Yd1z0);
                                      Y0grid<-unique(Yd0z1);
                                      L1<-length(Y1grid);
                                      L0<-length(Y0grid);
                                      Y1grid<-Y1grid[floor(seq.int(from=1, to=L1,length.out=(L1/size1)))];
                                      Y0grid<-Y0grid[floor(seq.int(from=1, to=L0,length.out=(L1/size0)))];
                                      return(list("Y1grid"=Y1grid, "Y0grid"=Y0grid));
}

###This function computes the empirical probabilities over the interval classes constructed by the function "generate.grids.coarse".

compute.PQ.grids<-function(data,m,n,grids){
                                    p1<-sum(data[1:m,2])/m;
                                    p0<-sum(data[(m+1):(m+n),2])/n;
                                    
                                    Yd1z1<-sort(subset(data[1:m,1], data[1:m,2]==1));
                                    Yd1z0<-sort(subset(data[(m+1):(m+n),1], data[(m+1):(m+n),2]==1));
                                    Yd0z1<-sort(subset(data[1:m,1], data[1:m,2]==0));
                                    Yd0z0<-sort(subset(data[(m+1):(m+n),1], data[(m+1):(m+n),2]==0));
                                    
                                    Qcdf.d1<-findInterval(grids$Y1grid,Yd1z0)/n;
                                    Pcdf.d1<-findInterval(grids$Y1grid,Yd1z1)/m;
                                    Qcdf.d0<-findInterval(grids$Y0grid,Yd0z0)/n;
                                    Pcdf.d0<-findInterval(grids$Y0grid,Yd0z1)/m;
                                    
                                    g1length<-length(grids$Y1grid);
                                    g0length<-length(grids$Y0grid);
                                    
                                    QV.d1<-triang(Qcdf.d1 - matrix(kronecker(rep(1,g1length), c(0,Qcdf.d1[1:(g1length-1)])), nrow=g1length, byrow=T));
                                    PV.d1<-triang(Pcdf.d1 - matrix(kronecker(rep(1,g1length), c(0,Pcdf.d1[1:(g1length-1)])), nrow=g1length, byrow=T));
                                    QV.d0<-triang(Qcdf.d0 - matrix(kronecker(rep(1,g0length), c(0,Qcdf.d0[1:(g0length-1)])), nrow=g0length, byrow=T));
                                    PV.d0<-triang(Pcdf.d0 - matrix(kronecker(rep(1,g0length), c(0,Pcdf.d0[1:(g0length-1)])), nrow=g0length, byrow=T));
                                    return(list("Q1"=QV.d1,"P1"=PV.d1, "Q0"=QV.d0, "P0"=PV.d0));
}


###This function returns the test statistic.

compute.stat<-function(data,m,n,lambda,xi,size1,size0){
                                           grids<-generate.grids.coarse(data,size1,size0);
                                           PQ<-compute.PQ.grids(data,m,n,grids);
                                           weight.d1<-pmax(xi,sqrt(lambda*PQ$Q1*(1-PQ$Q1)+(1-lambda)*PQ$P1*(1-PQ$P1)));
                                           weight.d0<-pmax(xi,sqrt(lambda*PQ$Q0*(1-PQ$Q0)+(1-lambda)*PQ$P0*(1-PQ$P0)));
                                                   
                                           Q_P.d1<-c(PQ$Q1-PQ$P1);
                                           P_Q.d0<-c(PQ$P0-PQ$Q0);
                                                   
                                           weightedQ_P.d1<-Q_P.d1/weight.d1;
                                           weightedP_Q.d0<-P_Q.d0/weight.d0;

                                           Tw<-(n*m/(n+m))^(0.5)*max(weightedQ_P.d1,weightedP_Q.d0);
                                           return(Tw)
}

###This function returns the test statistic given a specified class of intervals "grids"

compute.stat.grids.H<-function(data,m,n,grids,lambda,xi){
                                                      PQ<-compute.PQ.grids(data,m,n,grids);
                                                      weight.d1<-pmax(xi,sqrt(lambda*PQ$Q1*(1-PQ$Q1)+(1-lambda)*PQ$P1*(1-PQ$P1)));
                                                      weight.d0<-pmax(xi,sqrt(lambda*PQ$Q0*(1-PQ$Q0)+(1-lambda)*PQ$P0*(1-PQ$P0)));
                                                   
                                                      Q_P.d1<-c(PQ$Q1-PQ$P1);
                                                      P_Q.d0<-c(PQ$P0-PQ$Q0);
                                                   
                                                      weightedQ_P.d1<-Q_P.d1/weight.d1;
                                                      weightedP_Q.d0<-P_Q.d0/weight.d0;

                                                      Tw<-(n*m/(n+m))^(0.5)*max(weightedQ_P.d1,weightedP_Q.d0);
                                                      return(Tw)
}


##Compute Bootstrapped critical values given 
#data: original data
#m,n: two sample size	
#lambda: Pr(Z=1)
#PQ: the PQ list generated from function "compute.PQ"
#grids: the grids generated from function "generate.grids"
#B: Bootstrap iterations
#alpha: a sequence of significance level like c(0.1,0.05,0.01);
#xi: trimming constant

boot.cv<-function(data,m,n,lambda,B,alpha,xi,size1,size0){
                                              grids<-generate.grids.coarse(data,size1,size0);
                                              bootdata.array<-array(0,dim=c((m+n),3,B));
                                              for(b in 1:B){
                                              bootdata.array[,,b]<-data[sample(c(1:(m+n)), size=(m+n), replace=TRUE),];                                                                                 }
                                              bootstats<-apply(bootdata.array,3,compute.stat.grids.H, m=m, n=n, grids=grids,lambda=lambda,xi=xi);
                                              cvs<-quantile(bootstats,probs=(1-alpha));
                                              return(cvs)
}


### This function computes bootstrap p-values

boot.pval<-function(data,m,n,lambda,B,xi,size1,size0,teststat){
                                              grids<-generate.grids.coarse(data,size1,size0);
                                              bootdata.array<-array(0,dim=c((m+n),3,B));
                                              for(b in 1:B){
                                              bootdata.array[,,b]<-data[sample(c(1:(m+n)), size=(m+n), replace=TRUE),];                                                                                 }
                                              bootstats<-apply(bootdata.array,3,compute.stat.grids.H, m=m, n=n, grids=grids,lambda=lambda,xi=xi);
                                              pval<-sum(teststat <= bootstats)/B
                                              return(pval)
}


